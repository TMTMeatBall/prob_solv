# 이진 검색 / 백트래킹
#  ---------------
#  이진 검색
#  ---------------
# 자료 가운데의 idx 의 지정값과 비교하여 다음 검색의 위치를 결정하고, 검색을 계속해서 진행하는 것

# 시행 (정렬된 리스트 안에서)
# 중앙원소 고른다
# 원소값과 목표값을 비교
# 목표값>원소값인 경우 중앙원소 우측을, 반대의 경우 좌측을 검색
# 찾을 때까지 반복

# 의사코드
# A = [2,4,7,9,11,19,23]
# s, e = A[0],A[-1]
# m = A[len(A)//2]
# while s <= e:
#   if A[m] == key:
#       return m
#   elif A[m] > key:
#       e = m-1
#   else: #A[m] < key
#       s = m+1
#   return -1
#  high 1, low 0 의 경우에 mid가 1이므로 무한반복할 가능성 있으므로 e = m-1,s=m+1 로
# 검색 성공 / 1회로 찾는 경우 / 검색에 실패한 경우

# ---------------
# 백트래킹
# ---------------
# 엔퀸
# 노드가 promising,non-promising 여부를 확인하고, non인 경우에는 부모노드로 돌아가고 다른 자식노드를 택함
# 가지치기가 핵심
# worst case에서 시간복잡도가 2^n 가능성 있으므로, 가지치기를 잘 설정해야 함
# {1,2,3,4,5,6,7,8,9,10}의 powerset중 원소의 합이 10인 부분집합을 모두 출력하기
# def f(i,k,s,key):
#     global cnt
#     if i == k:
#         if s==key:
#             print(bit)
#             cnt += 1
#     else:
#         bit[i] = 0
#         f(i+1,k,s,key)
#         bit[i] = 1
#         f(i+1,k,s+A[i],key)
#
# A = [i for i in range(1,11)] #리스트
# N = 10 #중지점
# key = 10 #
# cnt = 0
# bit = [0] * N
# c = 0
# f(0,N,0,key)
# print(cnt,c)
# ----------------
# 상태공간 트리 도식화와 n-queen
# ----------------
# 완전탐색(DFS) + Pruning
# 기저조건 / 가지치기 / 메인 로직의 3단 구성
#
# ----------------
# 이진 트리
# ----------------
# 어떤 트리인지 파악할 것 [완전이진트리? 포화이진트리?
# 순회[전위(VLR),중위(LVR),후위(LRV)]
# 배열로 이진트리 표현 -[부모인덱스 - 자식번호저장]
# 각 노드별로 특정한 값이 지정되어 있다면 node 리스트 설정하고 부모인덱스 번호 따라 넣기
# ----------------
# 힙(heap)
# ----------------
# 최소 힙/최대 힙
